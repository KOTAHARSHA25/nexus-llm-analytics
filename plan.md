# Project Scrumban Plan

## Iteration 1: Foundation & Core APIs

**Goal:** Establish the backend framework and a working, secure API for LLM interaction and data handling.

**User Story:**  
_As a developer, I need to set up the core backend so I can build the application on a solid foundation._

### To Do

#### Project Setup
- Create a new project directory.
- Initialize a Python virtual environment (`venv`).
- Install core dependencies: `fastapi`, `uvicorn`, `crewai`, `ollama`, `pandas`, `polars`, `chromadb`, `plotly`, `python-dotenv`.
- Create a `requirements.txt` file to manage dependencies.

#### Ollama & LLM Integration
- Ensure Ollama is running locally.
- Download and pull the required models:
    - `ollama pull llama3:8b`
    - `ollama pull phi3:mini`

#### FastAPI Backend
- Create `main.py` with a basic FastAPI app.
- Set up a `POST /analyze` endpoint to receive user queries.

#### CrewAI Framework
- Define the initial roles and tools for the Controller Agent and Data Agent.
- Start with a simple sequential process to test the flow.

#### LLM Communication Layer
- Create a reusable helper function or class to handle API calls to the local Ollama server, abstracting away the specifics of the endpoint and payload structure.

#### Basic Code Execution Sandbox
- Implement a simple, temporary execution environment (e.g., using `exec()` with limited globals) for initial testing.  
    _Note: This is a placeholder; a more secure sandbox will be built in the next iteration._

#### Task for Data Agent 
- Write a simple task for the Data Agent to accept a query and generate Python code (e.g., using pandas) to answer it. The agent should also include comments and an explanation of the code it produces.

---

## Iteration 2: Self-Correction & Security

**Goal:** Implement the crucial security and self-correction features to make the application reliable and safe.

**User Story:**  
_As a developer, I need to make the code execution environment secure and add a self-correction mechanism to ensure accuracy._

### To Do

#### Secure Code Sandbox
- Replace the temporary execution environment with a production-ready, sandboxed solution like RestrictedPython.
- Configure RestrictedPython to allow only safe imports (`pandas`, `numpy`, `matplotlib`) and restrict access to system functions.

#### Review & Correction Agent
- Define the Review & Correction Agent's role in CrewAI.
- Create a task for this agent:  
    _"Review the code generated by the Data Agent. Look for errors, syntax issues, and potential security risks. If you find an issue, provide corrected code and a brief explanation."_
- Integrate this agent into a feedback loop within the CrewAI process.

#### Enhanced Error Handling
- Implement robust `try...except` blocks in the execution sandbox to catch and report errors gracefully.
- Add a logging system to track all LLM interactions, code execution results, and errors.

---

## Iteration 3: Unstructured Data & Vector DB

**Goal:** Add the ability to process and analyze unstructured data like PDFs.

**User Story:**  
_As a user, I want to be able to get insights from documents and PDFs, not just spreadsheets._

### To Do

#### File Ingestion Pipeline
- Develop a FastAPI endpoint (`/upload-documents`) to handle PDF, TXT, and JSON file uploads.
- Use a library like PyPDF2 or PyMuPDF to extract text from PDFs.

#### ChromaDB Integration
- Set up a ChromaDB client.
- Create a function to split ingested documents into chunks.
- Create embeddings for these chunks using the Ollama embedding model.
- Store the chunks and embeddings in a ChromaDB collection.

#### RAG Agent Development
- Define the RAG Agent's role:  
    _"Retrieve and analyze information from a document database to answer user queries."_
- Give this agent a tool to perform similarity searches on the ChromaDB vector store.

#### Orchestration Update
- Modify the Controller Agent to conditionally call the RAG Agent if the user's query and data type are relevant to unstructured data analysis.

---

## Iteration 4: Frontend UI & Visualization

**Goal:** Build a functional and visually appealing user interface for the application.

**User Story:**  
_As a user, I need a clean and intuitive interface to interact with the assistant and view the results._

### To Do

#### Next.js Project Setup
- Create a new Next.js project.
- Install dependencies: `tailwindcss`, `react-plotly.js`.

#### Main Dashboard Layout
- Design a responsive layout with a file upload area, a chat/query input, and a results display panel.

#### Components Development
- **File Uploader:** Create a component with drag-and-drop functionality that sends files to the FastAPI backend.
- **Query Input:** Build a text input field with a send button for user queries.
- **Results Display:** Create dynamic components to render different types of output:
    - A markdown-rendered component for text summaries and explanations.
    - A simple table component for displaying data frames.
    - A `react-plotly.js` component for rendering interactive charts.

#### API Connection
- Write a function to send the user query and file data to the FastAPI `/analyze` endpoint using `fetch` or `axios`.
- Handle the response from the backend and update the UI accordingly.

---

## Iteration 5: Reporting & Polish

**Goal:** Add the final feature of report generation and refine the overall user experience.

**User Story:**  
_As a user, I want to export my analysis into a professional, shareable report._

### To Do

#### Report Agent
- Define the Report Agent's role:  
    _"Compile the final analysis and results into a professional, formatted report."_

#### PDF Generation
- Implement a Python library like `reportlab` or `fpdf` in the backend.
- Create a new FastAPI endpoint (`/generate-report`) that takes the final analysis data (text summary, chart images, data tables) as input.
- Use the Report Agent to structure the final report and generate a PDF document.

#### Frontend Report Integration
- Add a "Download Report" button to the UI that calls the new `/generate-report` endpoint.

#### Final Review & Testing
- Conduct end-to-end testing to ensure the entire workflow, from file upload to report download, is working seamlessly.
- Make minor UI/UX tweaks to improve the look and feel, ensuring a polished final product.